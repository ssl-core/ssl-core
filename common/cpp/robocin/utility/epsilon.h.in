//
// Auto generated by CMake.
//

#ifndef ROBOCIN_UTILITY_EPSILON_H
#define ROBOCIN_UTILITY_EPSILON_H

#include <type_traits>

// clang-format off
#cmakedefine ROBOCIN_FLOAT_EPSILON ${ROBOCIN_FLOAT_EPSILON} // Injected by CMake.

#cmakedefine ROBOCIN_DOUBLE_EPSILON ${ROBOCIN_DOUBLE_EPSILON} // Injected by CMake.

#cmakedefine ROBOCIN_LONG_DOUBLE_EPSILON ${ROBOCIN_LONG_DOUBLE_EPSILON} // Injected by CMake.
// clang-format on

namespace robocin {

template <class T>
struct has_epsilon : std::false_type {}; // NOLINT(*naming*)

template <class T>
inline constexpr bool has_epsilon_v = has_epsilon<T>::value;

template <class T>
inline constexpr std::enable_if_t<has_epsilon<T>::value, T> epsilon_v = has_epsilon<T>::epsilon;

#if defined(ROBOCIN_FLOAT_EPSILON)
template <>
struct has_epsilon<float> : std::true_type {
  static constexpr float epsilon = ROBOCIN_FLOAT_EPSILON;

  static_assert(0.0F < epsilon and epsilon < 1.0F, "float epsilon must be in the range (0, 1).");
};
#endif

#if defined(ROBOCIN_DOUBLE_EPSILON)
template <>
struct has_epsilon<double> : std::true_type {
  static constexpr double epsilon = ROBOCIN_DOUBLE_EPSILON;

  static_assert(0.0 < epsilon and epsilon < 1.0, "double epsilon must be in the range (0, 1).");
};
#endif

#if defined(ROBOCIN_LONG_DOUBLE_EPSILON)
template <>
struct has_epsilon<long double> : std::true_type {
  static constexpr long double epsilon = ROBOCIN_LONG_DOUBLE_EPSILON;

  static_assert(0.0L < epsilon and epsilon < 1.0L,
                "long double epsilon must be in the range (0, 1).");
};
#endif

} // namespace robocin

#endif // ROBOCIN_UTILITY_EPSILON_H
