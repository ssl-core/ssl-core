syntax = "proto3";

package protocols.perception;

import "google/protobuf/timestamp.proto";
import "protocols/common/geometry.proto";
import "protocols/common/robot_id.proto";
import "protocols/third_party/detection/raw_wrapper.proto";
import "protocols/third_party/game_controller/tracked_wrapper.proto";

// DetectionWrapper is the message that encapsulates all types of detection available.
message DetectionWrapper {
  // The message generated by the perception service.
  Detection detection = 1;

  // Repeated raw detection data from a third-party simulator or ssl-vision.
  repeated third_party.detection.SSL_WrapperPacket raw_detections = 2;

  // Repeated tracked detection data from a third-party ssl-game-controller.
  repeated third_party.game_controller.TrackerWrapperPacket tracked_detections = 3;
}

// Detection is the message sent by the perception service to the rest of the system.
message Detection {
  // The incremental unique id of the detection.
  uint64 serial_id = 1;
  // The unix timestamp of the detection creation.
  google.protobuf.Timestamp created_at = 2;
  // The expected rate of detections generated (in frames per second).
  uint32 framerate = 3;

  // The list of detected balls, in order of confidence.
  repeated Ball balls = 4;
  // The list of detected robots (both teams).
  repeated Robot robots = 5;
  // The field information (sent periodically).
  optional Field field = 6;
}

// Ball is the message describing a game ball.
message Ball {
  // TODO(#33): add source.
  reserved 1;
  reserved "source";

  // The confidence of the ball detection [0-1].
  float confidence = 2;

  // The 3D position of the ball in the field (in millimeters).
  common.Point3Df position = 3;
  // The 3D velocity of the ball in the field (in millimeters per second).
  common.Point3Df velocity = 4;
  // TODO(#32): add ball acceleration.
  reserved 5;
  reserved "acceleration";

  // Information about the kick that last interacted with the ball, if exists.
  optional KickInformation kick_information = 6;

  // KickInformation describes the details of a kick.
  message KickInformation {
    // The id of the robot that kicked the ball.
    common.RobotId robot_id = 1;

    // The 2D position where the ball was kicked (in millimeters).
    common.Point2Df start_position = 2;
    // The 3D velocity of the ball at the start of the kick (in millimeters per second).
    common.Point3Df start_velocity = 3;
    // The timestamp when the ball was kicked.
    google.protobuf.Timestamp start_timestamp = 4;

    // The predicted 2D stop position of the ball (in millimeters).
    common.Point2Df predicted_stop_position = 5;
    // The predicted timestamp when the ball will stop.
    google.protobuf.Timestamp predicted_stop_timestamp = 6;
  }
}

// Robot is the message describing a game robot.
message Robot {
  // TODO(#33): add source.
  reserved 1;
  reserved "source";

  // The confidence of the robot detection [0-1].
  float confidence = 2;

  // The id of the robot.
  common.RobotId robot_id = 3;

  // The 2D position of the robot in the field (in millimeters).
  common.Point2Df position = 4;
  // The angle pointing in the direction the robot is facing, i.e. the robot's orientation (in radians).
  float angle = 5;

  // The 2D velocity of the robot in the field (in millimeters per second).
  common.Point2Df velocity = 6;
  // The angular velocity of the robot (in radians per second).
  float angular_velocity = 7;

  // TODO(#32): add robot acceleration.
  reserved 8;
  reserved "acceleration";

  // The radius of the robot (in millimeters).
  float radius = 9;
  // The height of the robot (in millimeters).
  float height = 10;
  // The width of the dribbler (in millimeters).
  float dribbler_width = 11;

  // The feedback from the robot.
  Feedback feedback = 12;

  // Feedback is the message describing the feedback from the robot.
  message Feedback {
    // Indicates if the dribbler has contact with the ball.
    optional bool dribbler_ball_contact = 1;
    // The charge percentage of the kick mechanism (from 0 to 1).
    optional float kick_charge_percentage = 2;
    // The battery percentage (from 0 to 1).
    optional float battery_percentage = 3;

    // Wheel is the message describing the state of an individual wheel.
    message Wheel {
      // The identifier for the wheel.
      uint32 wheel_id = 1;
      // The speed of the motor for the wheel.
      float motor_speed = 2;
    }

    // The list of wheels and their respective states.
    repeated Wheel wheels = 4;
  }
}

// Field is the message describing the game field.
message Field {
  // The incremental unique id of the field.
  uint64 serial_id = 1;

  // The length of the field (in millimeters).
  float length = 2;
  // The width of the field (in millimeters).
  float width = 3;
  // The depth of the goal (in millimeters).
  float goal_depth = 4;
  // The width of the goal (in millimeters).
  float goal_width = 5;
  // The depth of the penalty area (in millimeters).
  float penalty_area_depth = 6;
  // The width of the penalty area (in millimeters).
  float penalty_area_width = 7;
  // The width of the boundary (in millimeters).
  float boundary_width = 8;
  // The distance from the goal center to the penalty mark (in millimeters).
  float goal_center_to_penalty_mark = 9;
}
